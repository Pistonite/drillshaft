use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

use cu::pre::*;
use flate2::Compression;
use flate2::write::GzEncoder;
use ignore::WalkBuilder;
use sha2::{Digest, Sha256};
use tar::{Builder as TarBuilder, HeaderMode};

fn main() -> cu::Result<()> {
    let crate_path = PathBuf::from(cu::env_var("CARGO_MANIFEST_DIR")?);
    make_tools_targz(&crate_path)?;
    hash_tools_targz(&crate_path)
}

/// Pack the tools directory into a .tar.gz at hmgr/tools.tar.gz
fn make_tools_targz(crate_path: &Path) -> cu::Result<()> {
    let mut tar_builder = {
        let file = cu::fs::writer(tools_targz_path(crate_path))?;
        let gz_encoder = GzEncoder::new(file, Compression::default());
        let mut builder = TarBuilder::new(gz_encoder);
        builder.mode(HeaderMode::Deterministic);
        builder.follow_symlinks(false);
        builder
    };

    let tools_path = {
        let mut path = crate_path.parent_abs()?;
        path.push("tools");
        path
    };
    println!("cargo::rerun-if-changed={}", tools_path.as_utf8()?);

    // Create a Cargo.toml for tools that inherit dependencies versions
    // from shaft itself
    let workspace_cargo_toml = {
        let mut path = crate_path.parent_abs_times(2)?;
        path.push("Cargo.toml");
        cu::toml::parse::<cu::toml::Table>(&cu::fs::read_string(&path)?)?
    };

    let tools_cargo_content = {
        let mut out = r#"
[workspace]
resolver = "2"
members = [
    "shaftim",
    "shaftim-build",
]
"#
        .to_string();
        let mut new_table = cu::toml::Table::new();
        if let Some(workspace) = workspace_cargo_toml.get("workspace") {
            if let Some(deps) = workspace.get("dependencies") {
                let mut ws = cu::toml::Table::new();
                ws.insert("dependencies".to_string(), deps.clone());
                new_table.insert("workspace".to_string(), cu::toml::Value::Table(ws));
            }
        }
        out.push_str(&cu::toml::stringify_pretty(&new_table)?);
        out
    };
    let mut need_to_write_cargo_toml = true;
    if let Ok(content) = cu::fs::read_string(tools_path.join("Cargo.toml")) {
        let c2 = content
            .lines()
            .map(|x| x.trim())
            .collect::<Vec<_>>()
            .join("\n");
        let new_one = tools_cargo_content
            .lines()
            .map(|x| x.trim())
            .collect::<Vec<_>>()
            .join("\n");
        if c2 == new_one {
            need_to_write_cargo_toml = false;
        }
    }
    if need_to_write_cargo_toml {
        cu::fs::write(tools_path.join("Cargo.toml"), &tools_cargo_content)?;
    }

    {
        let bytes = tools_cargo_content.as_bytes();
        let mut header = tar::Header::new_gnu();
        header.set_path("Cargo.toml")?;
        header.set_size(bytes.len() as u64);
        header.set_mode(0o644);
        header.set_cksum();
        tar_builder.append(&header, bytes)?;
    }

    let mut builder = WalkBuilder::new(&tools_path);
    builder.filter_entry(|entry| {
        if entry.file_type().is_none_or(|x| !x.is_dir()) {
            return true;
        }
        cfg!(windows) || entry.file_name() != "__windows__"
    });
    builder.add_custom_ignore_filename(".corelibignore");

    for entry in builder.build() {
        let entry = entry?;
        let entry_path = entry.path();
        if !entry_path.is_file() {
            continue;
        }
        let rel_path = entry_path.try_to_rel_from(&tools_path);
        cu::ensure!(rel_path.is_relative(), "'{}'", rel_path.display())?;
        let mut file = cu::check!(
            File::open(entry_path),
            "failed to open '{}'",
            entry_path.display()
        )?;
        tar_builder.append_file(&rel_path, &mut file)?;
    }

    tar_builder.into_inner()?.finish()?.flush()?;
    Ok(())
}

fn hash_tools_targz(crate_path: &Path) -> cu::Result<()> {
    let bytes = cu::fs::read(tools_targz_path(crate_path))?;
    let mut hasher = Sha256::new();
    hasher.update(&bytes);
    let result = hasher.finalize();
    let mut out = String::with_capacity(64);
    let digits = b"0123456789abcdef";
    for b in result {
        let c1 = digits[(b / 16) as usize] as char;
        let c2 = digits[(b % 16) as usize] as char;
        out.push(c1);
        out.push(c2);
    }
    let gen_code = format!(
        r##"// generated by corelib build.rs
use crate::VersionCache;
pub static TOOLS_VERSION: VersionCache = VersionCache::new("corelib::TOOLS_VERSION", "{out}");
    "##
    );
    cu::fs::write(tools_genrs_path(crate_path), gen_code)
}

fn tools_targz_path(crate_path: &Path) -> PathBuf {
    let mut path = crate_path.to_path_buf();
    path.extend(["src", "hmgr", "tools.tar.gz"]);
    path
}

fn tools_genrs_path(crate_path: &Path) -> PathBuf {
    let mut path = crate_path.to_path_buf();
    path.extend(["src", "hmgr", "tools_targz.gen.rs"]);
    path
}
